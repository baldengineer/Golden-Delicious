.program KBD
.side_set 1 opt

mov x, null        ; fallback char if TX FIFO is empty
mov y, null        ; will store last decoded characters
; output pins (9 total)
; gpio 4-12 (d7-d0, en_245)

; input pins
; 17: KSEL0
; 18: KSEL1
; 19: KSEL2
; 20: R/W 
; 21: PH0
; 22: 
; 23: 
; 24:
; 25:

; KSEL0 to go HIGH
; KSEL1 and KSEL1 to be LOW
; RW to be HIGH
; PH0 low or high?
; ---
; KSEL2 go LOW
; KSEL1 is low?
; KSEL0 is HIGH or LOW
;
; KSEL0 is HIGH AND R/W is HIGH
; then we'll put data out when PH0 goes HIGH
; --or--
; KSEL1 is LOW and R/W is LOW 
; then we'll put data when PH0 goes HIGH 
; and then clear high bit of keyboard value

; AKD  1=key pressed 0=keys free
;
;; if KSEL0 == LOW and R/W == LOW, then do nothing
;; if KSEL0 == LOW and R/W == HIGH, then we put value on the bus
;; --
;; if KSEL0 == HIGH and R/W == XX, then we put value on bus and clear it
;;

; make sure the data bus is set to output
mov osr, ~ null    ; load FFs into OSR (for change to output)
out pindirs, 8     ; shift 8 FFs into pin direction register from OSR
nop side 1         ; disable data buffer

.wrap_target 
start:
    wait 0 gpio 19      ; KSEL2 
    wait 0 gpio 18      ; KSEL1 both seem to do the same thing
    jmp PIN, read_cyc   ; R/W pin, jumps if HIGH (Read)
    jmp start           ; if R/W low, this sa C000 call which is for 80col card

read_cyc:
    pull noblock        ; if FIFO empty, MOV OSR, X happens
    mov x, osr          ; check if there is a new character
    jmp !x output       ; a zero means no new character
    mov y, x            ; mmmm fresh char, save for next iteration
    jmp one_time_out

output:
    mov osr, y          ; repeat previous character nothing new in FIFO

one_time_out:
    wait 1 gpio 21      ; wait for Data Cycle

    out pins, 8 side 0  ; load out_pins register (7 bit data) from OSR

    ; was this C010 (or C000)?
    in PINS, 1          ; get KSEL0 from the input pins (bottom bit)
    mov x, ISR           ; move to x for comparison
    jmp X--, c010        ; KSEL0 is HIGH, so C010   
    jmp c000             ;
c010:
; turns 0xC1 into 0xC0,
;1100 0001
;1100 0000

;1000 0010
   /* mov x,y
    mov OSR, null
    out Y, 1
    mov OSR, x
    out Y, 7 */
    mov OSR, Y
  ;  out null, 1
    out Y, 7

c000:
    mov X, null        ; reset x for next iteration
past_c010:
    wait 0 gpio 21     ; wait for ENABLE to de-assert

;    out pindirs, 8     ; shfit 8 0s into pin dir register from OSR
     nop side 1
.wrap          ; do it again!


   ; I think this is where we set bit 7?

   

    ;out pindirs, 8     ; shift 8 FFs into pin direction register from OSR
    ;nop side 0
 ;   mov osr, null      ; load 0s into OSR (for change to Hi-Z)

    ; was this a C010 soft switch?
    ; in PINS, 1         ; get KSEL0 from the input pins (bottom bit)
    ; mov X, ISR         ; move to x for comparison
    ; jmp X--, c010_clear         ; C010 all is good
    ; mov X, y           ; reset x for next iteration
    ; jmp past_c010      ; clever name is clever